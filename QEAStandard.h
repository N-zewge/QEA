//////////////////////////////////////////////////////////////////////////////
//  
//	file: QEAStandard.h
//	Date: 2002.11.7
//	Copyright 2002 Kuk-Hyun Han. All rights reserved.
//	Description: QEA standard structure h (박사 논문용)
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// QEAStandard.h의 개념은 다음과 같다.
// 1. 논문용 코드를 작성하기 위해 구현한 header
// 2. class는 전혀 사용하지 않는다. (실행시간)
// 3. variables도 모두 전역으로 선언한다. 너무 많아서 정신 없으므로 struct에 모두 넣는다.
// 4. 이때 변수들의 size는 모두 define으로 결정한다.
// 5. 즉, 프로그램에서의 사용 순서는 다음과 같다.
//	  : 모든 #define -> #include "QEAStandard.cpp" -> main 코드
// 6. 실험 결과를 뽑기 위한 코드도 포함되어 있지만 철저히 #ifndef로 구현한다. (실행시간)
// 7. 모든 동작 관련 define들은 QEAdef.h 안에 들어있다.
// 8. QEA 구조는 생각할 수 있는 최대한의 확장 형태까지 가능토록 구현한다.
// 9. 즉, QEAStandard.cpp는 필요 함수들을 모아놓은 형태로 생각하면 된다.
// 10. 배포용 QEALib는 나중에 수정 구현하도록 한다.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#include <math.h>
#include <stdlib.h>
#include <windows.h>

// 모든 관련 define 포함한 header를 include한다.
#include "QEAdef.h"

// 시간 측정을 위해 include한다.
#include "HStopwatch.h"


#define QEA_POPSIZE_VAR		QEA_POPSIZE
#define QEA_NUMINGRP_VAR	QEA_NUMINGRP
#define QEA_TGLOBAL_VAR		QEA_TGLOBAL
#define QEA_NOBSERV_VAR		QEA_NOBSERV


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 전역 변수 선언

// Binary solution만을 위한 struct.
typedef struct {
	// Binary solutions 관련
	unsigned char sol[QEA_NBITS];				// Binary solutions
	double	fitness;							// Fitness value of sol
	bool	feasible;							// Feasibility of sol
} SBinarySol;


// 모든 QEA variables를 하나의 struct안에 넣자.
typedef struct {

	// current generation
	int		t;

	// population을 풀자.
	double	Qbit[QEA_POPSIZE][QEA_NBITS][2];				// Q-bit individual

	// Binary solutions 관련
	SBinarySol	X[QEA_POPSIZE][QEA_NOBSERV];				// Binary solutions (multiple observing 고려)

	// Best solutions 관련
	SBinarySol	B[QEA_POPSIZE];								// Best binary solution

	// Best of best
	SBinarySol	bb;											// 가장 상위의 best 값

} SQEAVar;

// 이제 진짜로 사용할 전역 변수를 선언하자.
SQEAVar	qea;

// QEA lookup table용 변수
double qeaLT[8] = QEA_INIT_LOOKUP;



// Data를 뽑기 위한 변수들도 하나의 struct로 묶어서 처리하자.
// Data를 뽑기 위한 변수들도 하나의 struct로 묶어서 처리하자.
// Data를 뽑기 위한 변수들도 하나의 struct로 묶어서 처리하자.
// Data를 뽑기 위한 변수들도 하나의 struct로 묶어서 처리하자.

// 마지막 결과 출력용 struct
typedef struct {
	SBinarySol	best_in_run[QEA_NRUNS];		// run별 best solution
	double best_fitness;					// run best중 가장 best 값
	double mean_fitness;					// run best들의 평균 값
	double worst_fitness;					// run best중 가장 worst 값
	double standard_dev;					// run best들의 표준 편차
	double mean_time;						// run당 평균 연산 소요 시간
	int mean_generation;					// run당 평균 generation
	int num_feasible_sol;					// feasible solution 개수
} SQEAResult;

// 시간 측정을 위해 선언
HStopwatch QEAwatch;

// QEA 결과 출력용 변수
SQEAResult qeaResult;


// 전역 변수 선언 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 함수 선언 (사용자 함수도 미리 선언을 해야 사용할 수 있다.)



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
// 기본 QEA용 함수들..


// Q-bit individual을 초기화한다. 맨 처음만 한 번 사용된다.
void QEA_initialize_Q(void);

#ifdef USER_INIT
// 사용자 정의 초기화 함수
void USER_initialize(void);
#endif

// make P(t) by observing the states of Q(t) : multiple observing p번 허용
void QEA_make_P(void);

#ifdef USER_REPAIR
// repair P(t) : constraint를 만족하지 못하는 solution은 수정한다.
void USER_repair(void);
#endif

// evaluate P(t) : 이 함수 내부에서 USER_objective function을 부른다.
void QEA_evaluate_P(void);

// Binary solution의 feasibility를 체크하는 user 함수 사용.
#ifdef USER_FEASIBILITY
bool USER_bFeasible(unsigned char x[]);
#endif

// user objective function
#ifdef USER_OBJECTIVE
double USER_objective(unsigned char x[]);
#endif


// store the best solutions among P(t) into B(t)
void QEA_storeBest0(void);		// Maximize problem

// termination condition을 user가 제공한다.
bool USER_isTerminate(double gamma);

// update Q(t) using Q-gates
void QEA_update_Q(void);		// 기본 Q update 함수
void QEA_update0(void);			// multiple X를 모두 이용하여 Q update

// store the best solutions among P(t) anb B(t-1) into B(t)
void QEA_storeBest(void);		// Maximize problem

// if (migration-condition) migrate globally or locally
void QEA_migrate(void);

// QEA 결과 분석
void QEA_analysis(void);

// 함수 선언 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 실험 결과 data file 생성을 위한 함수들

// solution.txt 생성.
void FILE_sol(void);

// 실험 결과 data file 생성을 위한 함수들 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////// Standard QEA ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////// Standard QEA ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////// Standard QEA ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// QEA 실행 main 함수 
// 1. t = 0
// 2. initialize Q(t)
//		2.5 initialze_User() : 사용자 정의 초기화 함수
// 3. make P(t) by observing the states of Q(t) : multiple observing p번 허용
//		3.5 repair P(t) : constraint를 만족하지 못하는 solution은 수정한다.
// 4. evaluate P(t)
// 5. store the best solutions among P(t) into B(t)
// 6. while (not termination-condition) do
// 7. t = t + 1
// 8. make P(t) by observing the states of Q(t-1) : multiple observing p번 허용
//		8.5 repair P(t) : constraint를 만족하지 못하는 solution은 수정한다.
// 9. evaluate P(t)
// 10. update Q(t) using Q-gates
// 11. store the best solutions among B(t-1) and P(t) into B(t)
// 12. store the best solution b among B(t)
// 13. if (migration-condition) migrate globally or locally

void QEArun(int run) 
{

	QEAwatch.start();
	//////////////////////////////////////////////////////
	//////////////////////////////////////////////////////
	//////////////////////////////////////////////////////
	//////////////////////////////////////////////////////

	// 1. t = 0
	qea.t = 0;

	// 2. initialize Q(t)
	QEA_initialize_Q();


#ifdef USER_INIT
	// 2.5 initialze_User() : 사용자 정의 초기화 함수
	USER_initialize();
#endif

	// 3. make P(t) by observing the states of Q(t) : multiple observing p번 허용
	QEA_make_P();

#ifdef USER_REPAIR
	// 3.5 repair P(t) : constraint를 만족하지 못하는 solution은 수정한다.
	USER_repair();
#endif

	// 4. evaluate P(t) : 이 함수 내부에서 USER_objective function을 부른다.
	QEA_evaluate_P();

	// 5. store the best solutions among P(t) into B(t)
	QEA_storeBest0();			
	
	// 6. while (not termination-condition) do
#ifndef USER_TERMINATE
	while (qea.t < QEA_MAXGENS)
#else
	#ifdef USER_TERMI_BEST
	while ( !USER_isTerminate(USER_TERMI_BEST) ) 
	#endif
#endif
	{
		// 7. t = t + 1
		qea.t++;

		// 8. make P(t) by observing the states of Q(t-1) : multiple observing p번 허용
		QEA_make_P();

#ifdef USER_REPAIR
		// 8.5 repair P(t) : constraint를 만족하지 못하는 solution은 수정한다.
		USER_repair();
#endif

		// 9. evaluate P(t)
		QEA_evaluate_P();
	
		// 10. update Q(t) using Q-gates
		QEA_update_Q();		// 기본 Q update 함수

		// 11. store the best solutions among B(t-1) and P(t) into B(t)
		// 12. store the best solution b among B(t)
		QEA_storeBest();

		
#ifdef QEA_TGLOBAL
		// 13. if (migration-condition) migrate globally or locally
		QEA_migrate();
#endif

	}

	//////////////////////////////////////////////////////
	//////////////////////////////////////////////////////
	//////////////////////////////////////////////////////
	//////////////////////////////////////////////////////
	QEAwatch.stop();

	/////////////////////////////////
	/////////////////////////////////
	/////////////////////////////////
	// 결과 저장. KHHAN_ANALYSIS
	qeaResult.best_in_run[run] = qea.bb;
	qeaResult.mean_time = (qeaResult.mean_time*run + QEAwatch.getDT()/1000.)/(run+1);
	qeaResult.mean_generation = (qeaResult.mean_generation*run + qea.t)/(run+1);
}


// QEA 실행 main 함수 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////// Standard QEA 끝./////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////// Standard QEA 끝./////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////// Standard QEA 끝./////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////// QEA 기본 함수 ///////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////// QEA 기본 함수 ///////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////// QEA 기본 함수 ///////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// QEA 기본 함수

#define QEA_INIT_ALPHA		(1./sqrt(2.))
#define QEA_INIT_BETA		(1./sqrt(2.))


// Q-bit individual을 초기화한다. 맨 처음만 한 번 사용된다.
void QEA_initialize_Q(void)
{
	// 초기화는 모든 Q-bit의 확률 값을 1/root(2)로 만들어주면 된다.
	for (int i=0; i<QEA_POPSIZE_VAR; i++) {
		for (int k=0; k<QEA_NBITS; k++) {
			qea.Qbit[i][k][0] = QEA_INIT_ALPHA;
			qea.Qbit[i][k][1] = QEA_INIT_BETA;
		}
	}
}

// make P(t) by observing the states of Q(t) : multiple observing p번 허용
void QEA_make_P(void)
{
	int i, j, k;
	double tmp, beta;

	// Binary solutions (multiple observing 고려)
	for (i=0; i<QEA_POPSIZE_VAR; i++) {
		for (j=0; j<QEA_NOBSERV_VAR; j++) {
			for (k=0; k<QEA_NBITS; k++) {
				// random 발생.
				tmp = (double)rand()/RAND_MAX;
				// Q-bit의 beta
				beta = qea.Qbit[i][k][1];
				if (tmp <= beta*beta) {
					qea.X[i][j].sol[k] = 1;
				}
				else {
					qea.X[i][j].sol[k] = 0;
				}
			}
		}
	}
}

// evaluate P(t) : 이 함수 내부에서 USER_objective function을 부른다.
void QEA_evaluate_P(void)
{
	int i, j;

	for (i=0; i<QEA_POPSIZE_VAR; i++) {
		for (j=0; j<QEA_NOBSERV_VAR; j++) {
			// fitness 값 계산.
#ifdef USER_OBJECTIVE
			// Fitness value of Xsol
			qea.X[i][j].fitness = USER_objective(qea.X[i][j].sol);
#else
			// basic objective value : number of 1s
			qea.X[i][j].fitness = 0.;
			for (int k=0; k<QEA_NBITS; k++) {
				qea.X[i][j].fitness += qea.X[i][j].sol[k];
			}
#endif

#ifdef USER_FEASIBILITY
	#ifdef QEA_NO_NEED_TO_FEASIBILITY_CHECK_EVERY_TIME
			qea.X[i][j].feasible = true;
	#else
			qea.X[i][j].feasible = USER_bFeasible(qea.X[i][j].sol);
	#endif
#else 
			qea.X[i][j].feasible = true;
#endif
		}
	}
}

// store the best solutions among P(t) into B(t)
// 처음 B(t)를 구할때는 P(t) 중에서만 고른다.
void QEA_storeBest0(void)
{
	int i, j;
	double best, bbest;
	int index, bindex;

	bbest = qea.X[0][0].fitness;
	bindex = 0;

	for (i=0; i<QEA_POPSIZE_VAR; i++) {
		best = qea.X[i][0].fitness;
		index = 0;
		for (j=1; j<QEA_NOBSERV_VAR; j++) {
#ifndef QEA_MINIMIZE
			if (best <= qea.X[i][j].fitness)		// maximize problem
#else
			if (best >= qea.X[i][j].fitness)		// minimize problem
#endif
			{
				best = qea.X[i][j].fitness;
				index = j;
			}
		}

		// store into B(t)
		qea.B[i] = qea.X[i][index];

		// store best of best
#ifndef QEA_MINIMIZE
		if (bbest <= qea.B[i].fitness)		// maximize problem
#else
		if (bbest >= qea.B[i].fitness)		// minimize problem
#endif

		{
			bbest = qea.B[i].fitness;
			bindex = i;
		}
	}

	qea.bb = qea.B[bindex];
}


// update Q(t) using Q-gates
void QEA_update_Q(void)		// 기본 Q update 함수
{
	QEA_update0();
}

// multiple X 모두 이용하여 Q update한다.
void QEA_update0(void)
{
	// 필요한 변수 선언
	double current_bestscore;
	double x_score;
	unsigned char x, b, c;
	int index, i, j, k;
	double sign, alpha, beta;
	double dth;

	for (i=0; i<QEA_POPSIZE_VAR; i++) {
		current_bestscore = qea.B[i].fitness;
		for (j=0; j<QEA_NOBSERV_VAR; j++) {
			x_score = qea.X[i][j].fitness;
#ifndef QEA_MINIMIZE
			c = (x_score >= current_bestscore) ? 1 : 0; //maximize
#else 
			c = (x_score <= current_bestscore) ? 1 : 0;	//minimize
#endif


// 2002.11.27 실행 시간을 줄이기 위한 추가 구현.
// 즉, c 값이 1이면 그냥 넘어간다.
			if (c == 1)
				continue;

			for (k=0; k<QEA_NBITS; k++) {
				x = qea.X[i][j].sol[k];
				b = qea.B[i].sol[k];
				index = x*4 + b*2 + c;

				// lookup table 값이 0이 아닐 경우에만 계산.
				if (qeaLT[index] != 0.) {
					alpha = qea.Qbit[i][k][0];
					beta = qea.Qbit[i][k][1];
					sign = alpha * beta;
					sign = sign/fabs(sign);

					dth = sign * qeaLT[index];

					// rotation gate
					qea.Qbit[i][k][0] = alpha*cos(dth) - beta*sin(dth);
					qea.Qbit[i][k][1] = alpha*sin(dth) + beta*cos(dth);
				}
			}
		}
	}
}



// store the best solutions among P(t) and B(t-1) into B(t)
// t >= 1 인 경우에는 P(t) and B(t-1) 중에서 B(t)를 고른다.
void QEA_storeBest(void)
{
	int i, j;
	double best, bbest;
	int index, bindex;

	// best of best를 찾기 위해.
	bbest = qea.B[0].fitness;
	bindex = 0;

	for (i=0; i<QEA_POPSIZE_VAR; i++) {
		best = qea.B[i].fitness;
		index = -1;
		for (j=0; j<QEA_NOBSERV_VAR; j++) {
#ifndef QEA_MINIMIZE
			if (best <= qea.X[i][j].fitness)		// maximize problem
#else
			if (best >= qea.X[i][j].fitness)		// minimize problem
#endif
			{
				best = qea.X[i][j].fitness;
				index = j;
			}
		}

		// best of best 찾자.
#ifndef QEA_MINIMIZE
		if (bbest <= best)		// maximize problem
#else
		if (bbest >= best)		// minimize problem
#endif
		{
			bbest = best;
			bindex = i;
		}

		// 현재 best가 가장 좋다.
		if (index == -1)
			continue;

		// store into B(t)
		qea.B[i] = qea.X[i][index];
	}

	// best of best 저장. store b among B(t)
	qea.bb = qea.B[bindex];
}


#ifdef QEA_TGLOBAL
// if (migration-condition) migrate globally or locally
void QEA_migrate(void)
{
	if (qea.t % QEA_TGLOBAL_VAR == 0) {
		// migrate globally
		// b 를 B(t)로 copy
		for (int i=0; i<QEA_POPSIZE_VAR; i++) {
			qea.B[i] = qea.bb;
		}
	}

#ifndef QEA_LOCAL_MIGRATE_OFF
	else if (qea.t % QEA_TLOCAL == 0) {
		// migrate locally
		// group 내부에서 가장 best를 찾자 group 내의 다른 B(t)에 copy
		// group 개수는?
		int numGrp = (QEA_POPSIZE_VAR/QEA_NUMINGRP_VAR) + ( (QEA_POPSIZE_VAR % QEA_NUMINGRP_VAR) ? 1 : 0 );
		// group best
		double best;
		int index;
		// pop index
		int i = 0;
		for (int g=0; g<numGrp; g++) {
			index = i;
			best = qea.B[index].fitness;
			for (int l=i+1; l<i+QEA_NUMINGRP_VAR && l<QEA_POPSIZE_VAR; l++) {
#ifndef QEA_MINIMIZE
				if (best <= qea.B[l].fitness)		// maximize problem
#else
				if (best >= qea.B[l].fitness)		// minimize problem
#endif
				{
					best = qea.B[l].fitness;
					index = l;
				}
			}

			// group best를 copy...
			for (int l=i; l<i+QEA_NUMINGRP_VAR && l<QEA_POPSIZE_VAR; l++) {
				if (l == index)
					continue;
				qea.B[l] = qea.B[index];
			}

			// i = ?
			i += QEA_NUMINGRP_VAR;
		}
	}
#endif // QEA_LOCAL_MIGRATE_OFF
}
#endif


// QEA 결과 분석
void QEA_analysis(void)
{
	// best, mean, worst fitness 값을 구하자.
	double temp_sum = 0.;
	double tmp;
	double temp_best = qeaResult.best_in_run[0].fitness;
	double temp_worst = qeaResult.best_in_run[0].fitness;
	int num_feasible_sol = 0;

	for (int r=0; r<QEA_NRUNS; r++) {
		if (qeaResult.best_in_run[r].feasible == true) {
			num_feasible_sol++;
			tmp = qeaResult.best_in_run[r].fitness;
			temp_sum += tmp;

#ifndef QEA_MINIMIZE
			if (temp_best <= tmp)	//maximize
				temp_best = tmp;
			if (temp_worst >= tmp)
				temp_worst = tmp;
#else
			if (temp_best >= tmp)	//minimize
				temp_best = tmp;
			if (temp_worst <= tmp)
				temp_worst = tmp;
#endif
		}
	}
	qeaResult.mean_fitness = (double)(temp_sum/num_feasible_sol);
	qeaResult.best_fitness = temp_best;
	qeaResult.worst_fitness = temp_worst;
	qeaResult.num_feasible_sol = num_feasible_sol;

	// standard deviation을 구하자.
	// sum {(x - mean)^2} / num
	temp_sum = 0.;
	for (int r=0; r<QEA_NRUNS; r++) {
		if (qeaResult.best_in_run[r].feasible == true) {
			temp_sum += (qeaResult.best_in_run[r].fitness - qeaResult.mean_fitness)*(qeaResult.best_in_run[r].fitness - qeaResult.mean_fitness);
		}
	}
	qeaResult.standard_dev = sqrt(temp_sum / num_feasible_sol);
	// standard deviation을 구하자. 끝.

	// 결과 file 출력?
	#ifdef FILE_SOLUTION
	FILE_sol();
	#endif
}


// QEA 기본 함수 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////// QEA 기본 함수 끝. ///////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////// QEA 기본 함수 끝. ///////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////// QEA 기본 함수 끝. ///////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// QEA 실험 data file 생성용 함수

// 각 run별 best solution과 통계를 저장.
// Solution.txt를 생성한다.
void FILE_sol(void)
{
	char filename[300] = "solution.txt";
	//sprintf(filename, "solution.txt");
	
	// file open
	FILE *fp = fopen(filename, "wt");

	// 먼저 run별 best를 출력.
	for (int r=0; r<QEA_NRUNS; r++) {
		for (int k=0; k<QEA_NBITS; k++) {
			fprintf (fp, "%d", qeaResult.best_in_run[r].sol[k]);
		}
		fprintf (fp, " => %lf\n", qeaResult.best_in_run[r].fitness);
	}

	fprintf(fp, "Best Fitness = %10.9lf\n", qeaResult.best_fitness);
	fprintf(fp, "Average Fitness = %10.9lf\n", qeaResult.mean_fitness);
	fprintf(fp, "Worst Fitness = %10.9lf\n", qeaResult.worst_fitness);
	fprintf(fp, "Standard dev. = %10.9lf\n", qeaResult.standard_dev);
	fprintf(fp, "Feasible Best Sol. # = %d\n", qeaResult.num_feasible_sol);
	fprintf(fp, "Average E. Time = %lf\n", qeaResult.mean_time);
	fprintf(fp, "Average Generation = %d\n", qeaResult.mean_generation);
	fclose(fp);
}

// QEA 실험 data file 생성용 함수 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

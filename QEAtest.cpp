//////////////////////////////////////////////////////////////////////////////
//   
//	file: QEAtest.cpp
//	Date: 2002.11.7
//	Copyright 2002 Kuk-Hyun Han. All rights reserved.
//	Description: QEA standard structure test cpp (박사 논문용)
//
//////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <time.h>

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 필요한 모든 #define 문들을 #include "QEAStandard.h" 이전에 넣어야 한다.
// 왜냐면 QEAStandard.cpp 안에서 사용할 #define문들이 미리 정의되어야 한다.



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// User definitions

#define DEJONG1
//#define DEJONG2
//#define DEJONG3
//#define DEJONG4
//#define DEJONG5

#ifdef DEJONG1
#define NVARS			3			// variables 개수
#define NBITS			18			// varialbe 당 bit 수
#define LBND			-5.12		// varialbe 값의 lower bound
#define UBND			5.12		// varialbe 값의 upper bound
#endif

#ifdef DEJONG2
#define NVARS			2			// variables 개수
#define NBITS			25			// varialbe 당 bit 수
#define LBND			-2.048		// varialbe 값의 lower bound
#define UBND			2.048		// varialbe 값의 upper bound
#endif

#ifdef DEJONG3
#define NVARS	5			// variables 개수
#define NBITS	18			// varialbe 당 bit 수
#define LBND	-5.12		// variables 의 lower bound
#define UBND	5.12		// variables 의 upper bound
#endif


#ifdef DEJONG4
#define NVARS	30			// variables 개수
#define NBITS	18			// varialbe 당 bit 수
#define LBND	-1.28		// variables 의 lower bound
#define UBND	1.28		// variables 의 upper bound
#endif


#ifdef DEJONG5
#define NVARS	2			// variables 개수
#define NBITS	18			// varialbe 당 bit 수
#define LBND	-65.536		// variables 의 lower bound
#define UBND	65.536		// variables 의 upper bound
#endif


// User definitions 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// QEA variables 전역 변수 관련 define

#define QEA_POPSIZE		15			// population size => Q-Bit Individual 개수
#define QEA_NVARS		NVARS		// variable 개수
#define QEA_NBITpVAR	NBITS		// variable당 bit수
#define QEA_NBITS		(QEA_NVARS*QEA_NBITpVAR)	// bit string length => #variables*#bits/var or SUM(bits/var) => 즉, 1차원 array
#define QEA_NOBSERV		2			// Q-bit individual을 몇 번 observing할 것인가? => 생성되는 binary string 개수
#define QEA_TGLOBAL		100			// Global migration period
#define QEA_TLOCAL		1			// Local migration period
#define QEA_NUMINGRP	3			// 1개의 group에 포함될 Q-bit 개체수 (즉, local migration 일어날 개체수)

#define QEA_NRUNS		10		// QEA를 몇 번 돌릴 것인가?

#define QEA_MAXGENS		1000		// QEA를 몇 generation까지 돌릴 것인가?

// 초기 lookup table
#define QEA_ANGLE		0.01*M_PI
#define QEA_INIT_LOOKUP {0., 0., QEA_ANGLE, 0., -QEA_ANGLE, 0., 0., 0.}	

// QEA variables 전역 변수 관련 define 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 사용자 정의 QEA 함수 관련 define
// define을 하면 user 함수를 사용하는 것으로 간주한다.
// define을 막으면 기본 함수만 사용하는 것으로 간주한다.

//#define	USER_INIT			// void USER_initialize(void) : 사용자 정의 초기화 함수
//#define	USER_REPAIR			// void USER_repair(void) : constraint를 만족하지 못하는 solution은 수정한다.

#define	QEA_MINIMIZE		// store the best solutions among P(t) into B(t)
								// 풀지 않으면 maximize, 풀면 minimize 문제

//#define	USER_FEASIBILITY	// bool USER_bFeasible(unsigned char x[]) : Binary solution의 feasibility를 체크하는 user 함수 사용.
#define	USER_OBJECTIVE		// double USER_objective(unsigned char x[]) : user objective function

//#define	USER_TERMINATE		// bool USER_isTerminate(void) : termination condition을 user가 제공한다.


// best의 확률을 이용한 termination condition
#define USER_TERMI_BEST		0.9


// 사용자 정의 QEA 함수 관련 define 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// Data 뽑기 위한 define

#define FILE_SOLUTION			// 각 run별 best solution과 통계를 저장.

// Data 뽑기 위한 define 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// QEAStandard.h를 include한다.
#include "QEAStandard.h"


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// User defined global variables




// User defined global variables 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 기타 user functions

// De jong F1
double Dejong_F1(double x[])
{
	double value = 0.;

	for (int i=0; i<NVARS; i++) {
		value += x[i]*x[i];
	}
	return value;
//	return (100.-value);
}

// De jong F2
double Dejong_F2(double x[])
{
	double value = 100.*(x[0]*x[0] - x[1])*(x[0]*x[0] - x[1]) + (1.-x[0])*(1.-x[0]);

	return value;
//	return (1./(value+.01));
//	return (100.-value);
}

double Dejong_F3(double *x)
{
	int i;
	double y=0.;
	for (i=0; i<NVARS; i++){
		if(x[i]<0)
			x[i]-=1;
		y+=(int)(x[i]);
	}
	return y;
}

double gaussian(double Xmean,double dev)
{
	double X=0;
	double y;
	X=2.56*(double)rand()/RAND_MAX;
	y=(1./sqrt(2*M_PI*dev*dev))*exp(-pow(X-Xmean,2)/(2.*dev*dev));
	return y;
}

double Dejong_F4(double *x)
{
	int i;
	double y=0.;
	for (i=0; i<NVARS; i++){
		y +=(i+1)*pow(x[i],4);
	}
	y +=gaussian(0.,1.);
	return y;
}

double Dejong_F5(double *x)
{
	int i,j;
	double y=0.;
	double f=0.;
	int A[2][25];
	
	for (j=0; j<25; j++){
		if((j%5)==0){
			A[0][j]=-32;
			if (j==0)
				A[1][j]=-32;
			else
				A[1][j]=A[1][j-1]+16;
		}
		else{
			A[0][j] = A[0][j-1] +16;
			A[0][j] = A[1][j-1];
		}
	}
	
	
	
	for (j=0; j<25; j++){
		f = j+1;
		for (i=0; i<2; i++){
			f +=pow ( (x[i]-A[i][j]),6);
		}
		y +=1./f;
	}
	y+=1./500;
	y=1./y;
	return y;
}

// Binary to Double
// 이때 v는 구하고자 하는 variable의 index
double Binary2Double(unsigned char x[], int v)
{
	double val = 0.;
	double rate = 1.;
	int k;

	for (k=(NBITS+v*NBITS); k>v*NBITS; k--) {
		val += (double)x[k-1]*rate;
		rate *= 2.;
	}

	val = LBND + val*(UBND-LBND)/(rate-1.);
	return val;
}



/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
// termination functions

#ifdef USER_TERMI_BEST
// 1. best의 확률을 이용한 termination condition
bool termi_best(double gamma)
{
	double total_prob = 0.;
	double probbest[QEA_POPSIZE];

	for (int i=0; i<QEA_POPSIZE; i++) {
		probbest[i] = 1.;
		for (int k=0; k<QEA_NBITS; k++) {
			probbest[i] *= qea.Qbit[i][k][qea.bb.sol[k]]*qea.Qbit[i][k][qea.bb.sol[k]];
		}
		total_prob += probbest[i];
	}
	total_prob /= QEA_POPSIZE;

	if (total_prob >= gamma)
		return true;
	else 
		return false;
}
#endif


// 기타 user functions 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 이제 main 코드를 시작한다.
void Analysis_JH(void)
{
	double temp_sum = 0;
	double tmp;
	double temp_best = qeaResult.best_in_run[0].fitness;
	double temp_worst = qeaResult.best_in_run[0].fitness;
	double nRun = (double)QEA_MAXGENS;
	
	for(int i=0; i<QEA_MAXGENS; i++)
	{
		tmp = qeaResult.best_in_run[i].fitness;
		temp_sum += tmp;
		if(temp_best >= tmp)
			temp_best = tmp;
		if(temp_worst <= tmp)
			temp_worst = tmp;
	}
	qeaResult.mean_fitness = (double)(temp_sum/nRun);
	qeaResult.best_fitness = temp_best;
	qeaResult.worst_fitness = temp_worst;
	
	//standard deviation
	temp_sum = 0;
	for(int i=0; i<QEA_MAXGENS; i++)
	{
		temp_sum += pow((qeaResult.best_in_run[i].fitness - qeaResult.mean_fitness),2.);
	}
	
	qeaResult.standard_dev= sqrt(temp_sum/nRun);
	
}

void main()
{

	srand((unsigned)time(NULL));


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// main core


	for (int i=0; i<QEA_NRUNS; i++) {

		QEArun(i);
	
		
		printf("run=%d ==> ", i);

		for (int v=0; v<NVARS; v++) 
			printf("x%d=%lf ", v, Binary2Double(qea.bb.sol, v));

		printf("==> f=%lf\n", qea.bb.fitness);
	}

	// 결과 분석.
	QEA_analysis();
//	Analysis_JH();

	std::cout << "Best Profit = " << qeaResult.best_fitness << std::endl;
	std::cout << "Mean Profit = " << qeaResult.mean_fitness << std::endl;
	std::cout << "Worst Profit = " << qeaResult.worst_fitness << std::endl;
	std::cout << "Standard dev = " << qeaResult.standard_dev << std::endl;
	std::cout << "# Feasible Sol = " << qeaResult.num_feasible_sol << std::endl;
	std::cout << "Elapsed time = " << qeaResult.mean_time << " msec" << std::endl;
	std::cout << "Average generation = " << qeaResult.mean_generation << std::endl;

// main core 끝.
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
}



// 이제 main 코드를 시작한다. 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// User defined functions for QEA

#ifdef USER_INIT
// 사용자 정의 초기화 함수
void USER_initialize(void)
{
}
#endif

#ifdef USER_REPAIR
// repair P(t) : constraint를 만족하지 못하는 solution은 수정한다.
void USER_repair(void)
{

}
#endif

#ifdef USER_FEASIBILITY
// Binary solution의 feasibility를 체크하는 user 함수 사용.
bool USER_bFeasible(unsigned char x[])
{
	return true;
}
#endif


#ifdef USER_OBJECTIVE
// user objective function
double USER_objective(unsigned char x[])
{
	double val[NVARS];

	for (int v=0; v<NVARS; v++) {
		val[v] = Binary2Double(x, v);
	}

	// De Jong Function 부르기...
#ifdef DEJONG1
	return Dejong_F1(val);
#endif
#ifdef DEJONG2
	return Dejong_F2(val);
#endif
#ifdef DEJONG3
	return Dejong_F3(val);
#endif
#ifdef DEJONG4
	return Dejong_F4(val);
#endif
#ifdef DEJONG5
	return Dejong_F5(val);
#endif

}
#endif


//#ifdef USER_TERMINATE
// termination condition을 user가 제공한다.
bool USER_isTerminate(double gamma)
{
#ifdef USER_TERMI_BEST
	return termi_best(gamma);
#endif
}
//#endif 


// User defined functions for QEA 끝.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

